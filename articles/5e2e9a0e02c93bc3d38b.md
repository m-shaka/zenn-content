---
title: "Brainfuckのwasmターゲットコンパイラを書いてwasmとWASIに入門"
emoji: "🧠"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["WebAssembly"]
published: false
---
# はじめに
ソースコードは[こちら](https://github.com/m-shaka/bf2wasm)においてあります。

WebAssembly（以下wasm）の勉強のために、Brainfuckのソースコードをwasmに変換するコンパイラを書きました。本稿はその解説記事になります。

生成したwasmバイナリは[Wasmtime](https://wasmtime.dev/)や[Wasmer](https://wasmer.io/)などのランタイムから実行できます。この記事では扱いませんが、追加でJSを書けばブラウザでも実行できると思います<!-- TODO: 標準入力の扱いが面倒くさそう -->。ちなみに実装言語はRustです。

## 背景
ご存知の方も多いと思いますが、Brainfuckはたった8つの命令からなるプログラミング言語です。人間が読んで理解するのは難しいですが、命令が少ないため処理系を書くのは比較的ちょろいです。今回はwasmの勉強が目的なのでおあつらえ向きと言えます。

ただ、wasmにコンパイルする場合には1つ問題があります。Brainfuckは入出力を扱う必要があり、コマンドラインならば標準入出力がそれに当たります。しかしwasm自体の主な機能は数値演算で、標準入出力を含むOSの機能を使うための仕組みがないのです。

そこで必要となるのがWASI（WebAssembly System Interface）です。WASI（WebAssembly System Interface）は名前の通りwasmプログラムからOSの機能を使うためのインターフェースです。WASIで定められたシグネチャを持つ実装をwasmの実行時に渡してあげることで標準入出力も扱えるようになります<!-- TODO: ソフトウェアデザインの紹介-->。上で紹介したWasmtimeやWasmerはWASIランタイムです。

ブラウザ外でのwasm利用は今後広まっていくことが予想されるので、いまコンパイラを書いておけば波に乗り遅れずに済みそうです。

## 本稿の構成
そんなこんなでコンパイラを書きましたので、本稿の目的を「WASIを使うwasmコードの作りかた」に据えていきます。以下のような流れで進行します。
- コンパイラの大まかな構成
- 実装に必要な範囲でのwasmとWASIの説明
- Brainfuckの各命令とそれに対応するwasmコードの説明
- 実行例

そして、以下の内容は**扱いません**。
- ブラウザでの実行方法
- Rustで書いたコンパイラのソースコードの解説
- Brainfuckの最適化

ブラウザの話は冒頭でも書いた通りで、今回はコマンドラインで使えるwasm（WASI）ランタイムでの実行を前提としています。また、命令の少なさに甘えて素朴に文字列として書き出すだけの雑実装にしたので、ソースコード自体には大した工夫はありません。最後のBrainfuckの最適化についてですが、今回の実装は筆者が以前[こちらの記事](https://postd.cc/adventures-in-jit-compilation-part-1-an-interpreter/)を参考にして書いたJITコンパイラからコードを流用しています。つまり、最適化についての詳細はそこに書いてあるのでそっちを参照してねということです。例外として、「連続した同じ命令を1つにまとめる」最適化は一言で説明すれば済むので扱います。

それでは本論に入っていきましょう。

# コンパイラの構成
このコンパイラは、Brainfuckプログラムのファイルを入力としてWebAssemblyのバイナリコードをファイル出力するプログラムです。WebAssemblyにはバイナリ形式とそれに対応するテキスト形式（以下wat）があります。ブラウザで実行するAPIが提供されているのは前者ですが、バイナリなので人間が読み書きするにはかなりつらいです。一方、後者は機械語に対するアセンブリのような位置づけのフォーマットで、普通に手書きできる程度には人間に優しいものです。今回は自前で実装するのはwatに生成するところまでにして、バイナリ形式への変換は別のライブラリに任せましょう。公式ツールである[wabt](https://github.com/WebAssembly/wabt)のRustバインディングを使います。

したがって、以下で説明するwasmコードは全てwatです。

# watとWASIの基礎
この節ではコンパイラ実装に必要なwatとWASIの仕様について解説していきます。まずBrainfuckの仕様を確認し、何が必要とされているのかを理解しましょう。

## Brainfuckの仕様
Brainfuckの仕様を[Wikipedia](https://ja.wikipedia.org/wiki/Brainfuck#Brainfuck%E3%81%AE%E8%A8%80%E8%AA%9E%E4%BB%95%E6%A7%98)から引用します。すでにご存知の方は次の小節まで読み飛ばしても大丈夫です。

> 処理系は次の要素から成る: Brainfuckプログラム、インストラクションポインタ（プログラム中のある文字を指す）、少なくとも30000個の要素を持つバイトの配列（各要素はゼロで初期化される）、データポインタ（前述の配列のどれかの要素を指す。最も左の要素を指すよう初期化される）、入力と出力の2つのバイトストリーム。
> Brainfuckプログラムは、以下の8個の実行可能な命令から成る（他の文字は無視され、読み飛ばされる）。
>
> `>` ポインタをインクリメントする。ポインタをptrとすると、C言語の「ptr++;」に相当する。
> `<` ポインタをデクリメントする。C言語の「ptr--;」に相当。
> `+` ポインタが指す値をインクリメントする。C言語の「(*ptr)++;」に相当。
> `-` ポインタが指す値をデクリメントする。C言語の「(*ptr)--;」に相当。
> `.` ポインタが指す値を出力に書き出す。C言語の「putchar(*ptr);」に相当。
> `,` 入力から1バイト読み込んで、ポインタが指す先に代入する。C言語の「*ptr=getchar();」に相当。
> `[` ポインタが指す値が0なら、対応する ] の直後にジャンプする。C言語の「while(*ptr){」に相当。
> `]` ポインタが指す値が0でないなら、対応する [ （の直後）にジャンプする。C言語の「}」に相当。

例として`12345`という文字列を出力するBrainfuckプログラムを載せておきます。`//`以下はコメントの気持ちで書いてます。Brainfuckにはコメント機能などありませんが、仕様にあるように無関係な文字は全て無視されるので、以下のプログラムは文法的に正しいBrainfuckプログラムです。

```
++++++++ ++++++++ ++++++++ ++++++++ ++++++++ ++++++++ // ポインタ0の値を48にする。ASCIIでは0
>+++++ // ポインタ1の値を5に。ループ用
[<+.>-] // ポインタ1が0になるまでポインタ0の値に1を加算して出力
```

Brainfuckの仕様を理解出来たところで、これらの命令を実行するために必要な機能をまとめると次のようになります。

- データポインタの保持
- メモリへの値のストア
- メモリからの値のロード
- 足し算と引き算
- 標準入出力
- 条件分岐とループ

本節では標準入出力までの説明を行い、「条件分岐とループ」については次の節で生成コードの解説を行う際に見ていくことにします。
