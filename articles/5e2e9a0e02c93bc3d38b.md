---
title: "Brainfuckのwasmターゲットコンパイラを書いてwasmとWASIに入門"
emoji: "🧠"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["WebAssembly"]
published: false
---
# はじめに
WebAssembly（以下wasm）の勉強のために、Brainfuckのソースコードをwasmに変換するコンパイラを書きました。本稿はその解説記事になります。ソースコードは[こちら](https://github.com/m-shaka/bf2wasm)においてあります。

生成したwasmバイナリは[Wasmtime](https://wasmtime.dev/)や[Wasmer](https://wasmer.io/)などのランタイムから実行できます。この記事では扱いませんが、追加でJSを書けばブラウザでも実行できると思います<!-- TODO: 標準入力の扱いが面倒くさそう -->。ちなみに実装言語はRustです。

## 背景
ご存知の方も多いと思いますが、Brainfuckはたった8つの命令からなるプログラミング言語です。人間が読んで理解するのは難しいですが、命令が少ないため処理系を書くのは比較的ちょろいです。今回はwasmの勉強が目的なのでおあつらえ向きと言えます。

しかし、wasmにコンパイルする場合には1つ問題があります。Brainfuckは入出力を扱う必要があり、コマンドラインならば標準入出力がそれに当たります。しかしwasm自体の主な機能は数値演算で、標準入出力を含むOSの機能を使うための仕組みがないのです。

詳しくは後述しますが、wasmとその実行環境（ホスト環境とも呼ばれます）は関数を相互に受け渡しできるので、OSの機能もそれを通して渡してあげればwasmからも使うことができます。ただ、各実装が好き勝手なインターフェースで書いてしまうと、ホスト環境とwasmプログラムが密に結合しかねず可搬性が下がります。

そこで提案されたのがWASI（WebAssembly System Interface）です。WASIはwasmプログラムからOSの機能を使うための決まりごとのようなものです。WASIに従ってwasmを作れば、WASIに対応する全てのホスト環境で実行することができるのです。<!-- TODO: ソフトウェアデザインの紹介-->。上で紹介したWasmtimeやWasmerはWASIランタイムの1つです。

WASIはブラウザ外でのwasm利用を推し進めるために提案された仕様です。ブラウザ外wasmは今後どんどん広まると予想されるので、ここでWASIに対応したコンパイラを書いて勉強しておけば波に乗っていけるかも知れません。

## 本稿の構成
そんなこんなでコンパイラを書いたので、「WASI準拠のwasmコードの作りかた」の理解をこの記事の目標にしたいと思います。本稿は以下のような流れで進行します。

- コンパイラの大まかな構成
- 実装に必要な範囲でのwasmの基礎
- WASI対応コードの説明
- Brainfuckの各命令とそれに対応するwasmコードの説明
- 実行例

wasmとWASIがメインなのでそこが一番分厚くなります。コンパイラに興味が無い場合はそこだけ読むことも可能です。そして、以下の内容は**扱いません**。

- ブラウザでの実行方法
- Rustで書いたコンパイラのソースコードの解説
- Brainfuckの最適化

ブラウザの話は冒頭でも書いた通りで、今回はコマンドラインで使えるwasm（WASI）ランタイムでの実行を前提としています。また、命令の少なさに甘えて素朴に文字列として書き出すだけの雑実装にしたので、ソースコード自体には大した工夫はありません。最後のBrainfuckの最適化についてですが、今回の実装は筆者が以前[こちらの記事](https://postd.cc/adventures-in-jit-compilation-part-1-an-interpreter/)を参考にして書いたJITコンパイラからコードを流用しています。つまり、最適化についての詳細はそこに書いてあるのでそっちを参照してねということです。例外として、「連続した同じ命令を1つにまとめる」最適化は一言で説明すれば済むので扱います。

それでは本論に入っていきましょう。

# コンパイラの構成
このコンパイラは、Brainfuckプログラムのファイルを入力としてWebAssemblyのバイナリコードをファイル出力するプログラムです。WebAssemblyにはバイナリ形式とそれに対応するテキスト形式（以下wat）があります。ブラウザで実行するAPIが提供されているのは前者ですが、バイナリなので人間が読み書きするにはかなりつらいです。一方、後者は機械語に対するアセンブリのような位置づけのフォーマットで、見た目はほとんどS式なので普通に手書きできる程度には人間に優しいものです。今回は自前で実装するのはwatに生成するところまでにして、バイナリ形式への変換は別のライブラリに任せましょう。公式ツールである[wabt](https://github.com/WebAssembly/wabt)のRustバインディングを使います。

したがって、以下で説明するwasmコードは全てwatです。

# watの基礎
この節では、WASIにたどり着くことを目標にwatの基本事項について確認していきます。なるべくSelf-Containedになるよう努めた結果、記述がたいへん長くなってしまったため随所で不自然な省略をしています。より詳しく知りたい場合は[MDNの記事](https://developer.mozilla.org/ja/docs/WebAssembly/Understanding_the_text_format)や[公式ドキュメント](https://webassembly.github.io/spec/core/index.html)などを参照して下さい。

これからwatコードを見つつ説明していきますが、それに先立って簡易的な実行環境を紹介しておきましょう。次のNode.jsスクリプトは、ファイルから読んだwatのコードをwabtでバイナリに変換してからコンパイルするものです。

```javaScript:run_wat.js
const { readFile } = require("fs/promises");
const wabt = require("wabt");

const importObject = {};

async function main() {
    const wabtMod = await wabt();
    const sourcePath = process.argv[2];
    const source = await readFile(sourcePath, 'utf-8');
    const wasmModule = wabtMod.parseWat(sourcePath, source);
    const { buffer } = wasmModule.toBinary({});
    const module = await WebAssembly.compile(Buffer.from(buffer));
    const instance = await WebAssembly.instantiate(module, importObject);
}

main()
```

`npm i wabt`で依存を入れてから`node run_wat.js path/to/wat/file`を実行して下さい。実はこのスプリクトでは何も起こらないのですが、読み込んだwatファイルに不具合があればコンパイルエラーで教えてくれます。`importObject`も空で宣言していますが、これは後で使うときに説明します。

## module
さて、wasmプログラムはモジュールから構成されています。

```wasm
(module) ;; これはコメント
```
わざわざ宣言文が用意されているので複数宣言できそうな気がしてしまいますが、現在の仕様では1プログラムにつき1モジュールのようです。これは何も定義していない空のモジュールですが正しいwatなので、先程の`run_wat.js`に渡せば正常終了するはずです。

モジュール内には様々なコンポーネントを配置できますが、今回必要なのは`func`, `global`, `memory`, `export`, `import`の5つです。一番重要なのは命令を記述するための`func`なのでまずはそこから見ていきましょう。

## func
### 宣言
`$f`という名前で関数を宣言してみましょう。

```wasm
(module
    (func $f)
)
```

名前はオプショナルなので単に`(func)`とも書けます。名前を付けなくても、宣言順に0始まりの添え字が割り当てられるのでそれを使って参照できます（呼び出しについては後述）。

引数を受け取りたい場合は宣言を次のように変更します。

```wasm
(func $f (param i32) (param i32))
```

これでi32型の値を2つ引数として受け取る関数を定義できました。

### 呼び出し
これを他の関数から呼び出すときは次のように書きます。

```wasm
(func $f (param i32) (param i32))
(func $g
    i32.const 1
    i32.const 2
    call $f ;; `call 0`でもよい
)
```

wasmはスタックマシンなので、スタックにオペランドをプッシュしておき、それをポップして演算を呼び出していきます。上の例ではi32の`1`と`2`を引数として`$f`を呼び出しています。自分はこう書いた方がスタックマシンっぽくて好んで書いていますが、S式っぽく次のようにも書けます。

```wasm
(call $f (i32.const 1) (i32.const 2))
```

「ではどうやって`$f`の中で引数を使うのか？」という疑問が浮かぶと思いますが、実は今回必要となるのは引数を取る関数の宣言方法だけなのでなんと説明しません。知りたい場合は冒頭で挙げた参考文献をあたって下さい。

### 数値演算
これは`1 + 2`を実行する関数です。

```wasm
(func
    ;; (i32.add (i32.const 1) (i32.const 2))でもよい
    i32.const 1
    i32.const 2
    i32.add
    drop
)
```

`i32.add`はスタックから2つ値をポップして、それらを足し合わせた結果をスタックに積む演算です。最後の`drop`はスタックの最上位を破棄する命令です。スタックに値があると関数の戻り値として解釈されますが、この関数は戻り値がないことになっているためエラーになります。戻り値を設定することもできますが、やはり今回は必要ないのでスルーします。

もちろん`i32.add`以外にも基本的なi32演算は揃っていますが、他の演算については必要になったときに紹介していくことにして`global`コンポーネントの説明に移ります。

## global
グローバル変数を定義するの用います。

```wasm
(global $g (mut i32) (i32.const 1))
(func
    global.get $g ;; `global.get 0`も可
    i32.const 2
    i32.add
    drop
)
```

これも`1 + 2`を実行して捨てるコードです。ここでは関数で説明したのと同じやり方で、グローバル変数に名前`$g`を割り当てています。名前を付けなくても添え字でアクセスできるのも同様です。`mut i32`は変更可能なi32型の値であることを表し、`i32.const 1`は初期値が`1`であることを示しています。

次のコードはこのグローバル変数を`2`に変更するものです。

```wasm
(func
    i32.const 2
    global.set $g
)
```

## memory
メモリを初期化するためのセクションです。メモリは1バイトずつ格納する単なる一次元配列で、1ページ64KiBとして宣言時に最小のページ数を指定します。

```wasm
(module
    (memory 1)
)
```

こうすると1ページのメモリを確保できます。関数と同様、0始まりのインデックスが振られており名前を付けることも可能ですが、現在の仕様では1モジュールにつき1インスタンスしか作れないので名前を付けてもあまり意味はありません。

中身は全て`0`で初期化されており、メモリへの値の保存は関数の中で行います<!-- TODO: dataについて補足 -->。メモリのオフセット0の位置に`1`を格納してみましょう。

```wasm
(func
    ;; (i32.store8 (i32.const 0) (i32.const 1))でも可
    i32.const 0
    i32.const 1
    i32.store8
)
```

ストア命令には注意が必要です。i32型のストア命令には`i32.store8`, `i32.store16`, `i32.store`の3種類があり、使う命令を間違えると意図しない書き込みが行われてしまいます。これらは第一引数のi32値をオフセットとして、それぞれ8ビット、16ビット、32ビットを書き込む命令です。例えば今のメモリの状態がこんな風になっているとします。

|番地|値（1バイト）|
|:-:|:-:|
|0|0|
|1|10|
|2|20|
|3|30|

この状態で次のような命令を実行するとどうなるでしょうか。

```wasm
i32.const 0
i32.const 1
i32.store
```

第一引数はあくまでオフセットなので、`0`から初めて32ビットを書き込むことになります。`1`を32ビットの二進数で書くと`00000000000000000000000000000001`なので、実行後の状態はこうなります。

|番地|値|
|:-:|:-:|
|0|1|
|1|0|
|2|0|
|3|0|

1, 2, 3番目のセルが0で上書きされています。n番目のセルだけに8ビット範囲の整数を書き込みたい場合は`i32.store8`を使います。

メモリからの読み込みについても同様の注意が必要です。`i32.load`命令は第一引数のオフセット値から32ビットを読み込むので、

|番地|値|
|:-:|:-:|
|0|0|
|1|10|
|2|20|
|3|30|

の状態で`(i32.load (i32.const 0))`を実行するとスタックの一番上には`504629760`が積まれます。`(30 << 24) + (20 << 16) + (10 << 8) + 0`と等しいですね。よって、ちょうど0番目のセルのバイトだけを読んでスタックに積みたい場合はこう書かねばなりません。

```wasm
i32.const 0
i32.load8_u
```

`_u`というサフィックスは符号なし整数として読み込むという意味です。符号ありとして読み込む場合は`i32.load8_s`を使いますがやはり今回は使いません。

命令に関する説明は以上になります。実際にはループやifなどの制御構文も使うのですが、それらはWASIの説明には不要なのでコンパイラの生成コードとまとめて説明します。

## exportとimport
先程も述べたように、wasmコードとそれを実行するホスト環境は関数やメモリの受け渡しができます。`export`はwasmからホスト環境へ渡すための文です。

`add.wat`というファイルを作り、`1 + 2`を実行して捨てるだけの関数を`main`という名前でエクスポートしてみましょう。

```wasm:add.wat
(module
    ;; (func (export "main)とまとめることもできる
    (func
        i32.const 1
        i32.const 2
        i32.add
        drop
    )
    (export "main" (func 0))
)
```

そして`run_wat.js`の`main`関数の最後の行に`instance.exports.main()`という式を付け足します。

```javaScript:run_wat.js
const { readFile } = require("fs/promises");
const wabt = require("wabt");

const importObject = {};

async function main() {
    const wabtMod = await wabt();
    const sourcePath = process.argv[2];
    const source = await readFile(sourcePath, 'utf-8');
    const wasmModule = wabtMod.parseWat(sourcePath, source);
    const { buffer } = wasmModule.toBinary({});
    const module = await WebAssembly.compile(Buffer.from(buffer));
    const instance = await WebAssembly.instantiate(module, importObject);
    instance.exports.main() // +
}

main()
```

`instance.exports`でwasmからエクスポートされた関数にアクセスできます。スタックに積んで捨てるだけのコードなので何も起こりませんが正常終了します。これを`instance.exports.hoge()`と変えて実行すればエラーになります。`hoge`という名前はエクスポートしていないので`undefined`になるからです。

こんな何も起こらない関数を実行しても何も面白くないですよね。エクスポートした関数に戻り値があればもうちょっとわかりやすい結果が出せるのですが、戻り値の説明をしないという縛りを自らに科したためそれはできません。

そこで`import`を紹介します。`import`を使えば、wasmプログラムから参照する関数をホスト環境から渡すことができます。また`run_wat.js`をいじりましょう。

```javaScript:run_wat.js
const importObject = {
    console: {log: console.log}
};
```

空だった`importObject`を修正しました。`console`モジュールの`log`という名前に`console.log`を割り当てました。これを`WebAssembly.instantiate`に渡せば`console.log`がwasmから参照できます。`add.wat`も変更しましょう。

```wasm:add.wat
(module
    (import "console" "log" (func $log (param i32))) ;; +
    (func (export "main")
        i32.const 1
        i32.const 2
        i32.add
        call $log
    )
)
```

`import`の宣言によって`importObject`で渡した`console.log`を`$log`という名前で参照できるようになりました。これを`run_wat.js`に渡して実行すると`3`と出力されるはずです。

# WASI
前節ではwasmの命令の基礎と、`export`と`import`を通してホスト環境とやり取りする方法を学びました。これで準備が整ったので、WASIの説明に移りたいと思います。

繰り返しになりますが、WASIはOSの機能をwasmから使うための決まりごとです。先程の例では、JavaScriptの`console.log`をインポートしてwasmから使えるようにしました。しかし、`console`モジュールの`log`という名前でインポートすることを決めたのは筆者です。それでは第三者がこのプログラムを使いたい場合に不便です。

そこでWASIです。WASIはwasmからのexportとホスト環境からのimportの約束事を定めています。まずwasmプログラムからはエントリーポイントとして`_start`という名前で関数を、`memory`という名前でメモリインスタンスをエクスポートすることが求められます<!-- TODO: リアクターは謎 https://github.com/WebAssembly/WASI/blob/main/design/application-abi.md -->。

```wasm:wasi.wat
(module
    (memory (export "memory") 1)
    (func (export "_start"))
)
```

このwatコードはWasmerで実行できます。雑に`wasi.wat`という名前で保存して`wasmer run wasi.wat`と叩けば正常終了するはずです。

今度はホスト環境からのインポートです。WasmerやWasmtimeは勝手にインポートオブジェクトを渡してくれているのでwasm側に`import`宣言を書いてあげます。

```wasm:wasi.wat
(module
    (import "wasi_snapshot_preview1" "fd_write" (func $fd_write (param i32 i32 i32 i32) (result i32)))
    (memory (export "memory") 1)
    (func (export "_start"))
)
```

`wasi_snapshot_preview1`と`fd_write`はWASIが定めたモジュールと関数です。`fd_write`はファイル書き込みのための関数です。試しに標準出力に`0`と書き込んでみましょう。なお、ここの説明は[Wasmtimeのチュートリアル](https://github.com/bytecodealliance/wasmtime/blob/main/docs/WASI-tutorial.md#web-assembly-text-example)を参考にしています。

```wasm:wasi.wat
(module
    (import "wasi_snapshot_preview1" "fd_write" (func $fd_write (param i32 i32 i32 i32) (result i32)))
    (memory (export "memory") 1)
    (func (export "_start")
        ;; 文字0のコードポイントをメモリの8番目に格納
        (i32.store8 (i32.const 8) (i32.const 48))

        ;; iov。出力するデータのポインタを指定。今回は8番目
        (i32.store8 (i32.const 0) (i32.const 8))
        ;; iov。出力する文字列の長さ。今回は1
        (i32.store8 (i32.const 4) (i32.const 1))

        (call $fd_write
            (i32.const 1) ;; file descriptor
            (i32.const 0) ;; iov配列のポインタ
            (i32.const 1) ;; iovの長さ
            (i32.const 20) ;; 書き込んだバイトの長さを格納するメモリのオフセット
        )
        drop
    )
)
```
`fd_write`の第一引数はファイルディスクリプタの番号です。今回は標準出力なので`1`になります。第2、第3引数には出力するバイトの情報を表す`iov`というデータ構造の配列のベースポインタと長さを渡して下さい。`iov`の最初の4バイトでは出力するデータの入ったメモリのオフセットを指定し、続く4バイトは出力するバイト数を指定します。今回は文字`0`のコードポイントである`48`をメモリの8番地に格納しているので、`8`を最初の4バイトに入れて、長さ`1`を続く4バイトに保存しています。`iov`配列の始まりはメモリの0番地にしたので第2引数に`0`を渡し、`iov`は1つしかないので第3引数は`1`になります。最後の引数はファイルディスクリプタに書き込まれたバイト数を`fd_write`が書き込むためのメモリオフセットを指定するためのもので、今回は使わないためどこでもよいので適当に決めました。

このコードを先ほどと同じようにWasmerで実行するとコンソールに`0`が出力されるはずです。Wasmtimeでも同様に実行できます。これでWASIランタイムで実行可能なwatコードが完成しました。

標準入力もほぼ同じAPIで使えるので、ここではコメントを添えたコードの引用だけにとどめます。

```wasm
(module
    (import "wasi_snapshot_preview1" "fd_read" (func $fd_read (param i32 i32 i32 i32) (result i32)))
    (import "wasi_snapshot_preview1" "fd_write" (func $fd_write (param i32 i32 i32 i32) (result i32)))
    (memory (export "memory") 1)
    (func (export "_start")
        ;; iov。読み込んだバイトを格納するメモリオフセットの指定
        (i32.store8 (i32.const 4) (i32.const 0))
        ;; iov。読み込むバイト数を指定
        (i32.store8 (i32.const 8) (i32.const 1))

        (call $fd_read
            (i32.const 0) ;; 標準入力
            (i32.const 4) ;; iov
            (i32.const 1) ;; iov長さ
            (i32.const 20)
        )
        drop

        (i32.store8 (i32.const 4) (i32.const 0))
        (i32.store8 (i32.const 8) (i32.const 1))

        (call $fd_write
            (i32.const 1)
            (i32.const 4)
            (i32.const 1)
            (i32.const 20)
        )
        drop
    )
)
```

# コード生成
ここまでで学んだ知識を使ってコンパイラを作っていきましょう。まずBrainfuckの仕様を[Wikipedia](https://ja.wikipedia.org/wiki/Brainfuck#Brainfuck%E3%81%AE%E8%A8%80%E8%AA%9E%E4%BB%95%E6%A7%98)から引用します。

> 処理系は次の要素から成る: Brainfuckプログラム、インストラクションポインタ（プログラム中のある文字を指す）、少なくとも30000個の要素を持つバイトの配列（各要素はゼロで初期化される）、データポインタ（前述の配列のどれかの要素を指す。最も左の要素を指すよう初期化される）、入力と出力の2つのバイトストリーム。
> Brainfuckプログラムは、以下の8個の実行可能な命令から成る（他の文字は無視され、読み飛ばされる）。
>
> `>` ポインタをインクリメントする。ポインタをptrとすると、C言語の「ptr++;」に相当する。
> `<` ポインタをデクリメントする。C言語の「ptr--;」に相当。
> `+` ポインタが指す値をインクリメントする。C言語の「(*ptr)++;」に相当。
> `-` ポインタが指す値をデクリメントする。C言語の「(*ptr)--;」に相当。
> `.` ポインタが指す値を出力に書き出す。C言語の「putchar(*ptr);」に相当。
> `,` 入力から1バイト読み込んで、ポインタが指す先に代入する。C言語の「*ptr=getchar();」に相当。
> `[` ポインタが指す値が0なら、対応する ] の直後にジャンプする。C言語の「while(*ptr){」に相当。
> `]` ポインタが指す値が0でないなら、対応する [ （の直後）にジャンプする。C言語の「}」に相当。

例として`12345`という文字列を出力するBrainfuckプログラムを載せておきます。`//`以下はコメントの気持ちで書いてます。Brainfuckにはコメント機能などありませんが、仕様にあるように無関係な文字は全て無視されるので、以下のプログラムは文法的に正しいBrainfuckプログラムです。

```
++++++++ ++++++++ ++++++++ ++++++++ ++++++++ ++++++++ // ポインタ0の値を48にする。ASCIIでは0
>+++++ // ポインタ1の値を5に。ループ用
[<+.>-] // ポインタ1が0になるまでポインタ0の値に1を加算して出力
```

さて、命令以外の要件を見ておきます。「30000個の要素を持つバイトの配列（各要素はゼロで初期化される）」は1ページのメモリインスタンスを作ればそれでよさそうです。「データポインタ」は可変のグローバル変数に格納しましょう。「入力と出力の2つのバイトストリーム」は標準入出力を使います。生成コードの雛形はこんな感じになるでしょう。メモリの0 ...11番目は標準入出力のために使うので、データポインタの初期値は12にしました。

```wasm
(module
    (import "wasi_snapshot_preview1" "fd_read" (func $fd_read (param i32 i32 i32 i32) (result i32)))
    (import "wasi_snapshot_preview1" "fd_write" (func $fd_write (param i32 i32 i32 i32) (result i32)))

    (memory (export "memory") 1)
    (global $index (mut i32) (i32.const 12)) ;; データポインタ
    (func (export "_start"))
)
```

それでは命令を1つずつwatに変換していきましょう。

## `>`
