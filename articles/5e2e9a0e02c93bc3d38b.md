---
title: "Brainfuckのwasmターゲットコンパイラを書いてwasmとWASIに入門"
emoji: "🧠"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["WebAssembly"]
published: false
---
# はじめに
ソースコードは[こちら](https://github.com/m-shaka/bf2wasm)においてあります。

WebAssembly（以下wasm）の勉強のために、Brainfuckのソースコードをwasmに変換するコンパイラを書きました。本稿はその解説記事になります。

生成したwasmバイナリは[Wasmtime](https://wasmtime.dev/)や[Wasmer](https://wasmer.io/)などのランタイムから実行できます。この記事では扱いませんが、追加でJSを書けばブラウザでも実行できると思います<!-- TODO: 標準入力の扱いが面倒くさそう -->。ちなみに実装言語はRustです。

## 背景
ご存知の方も多いと思いますが、Brainfuckはたった8つの命令からなるプログラミング言語です。人間が読んで理解するのは難しいですが、命令が少ないため処理系を書くのは比較的ちょろいです。今回はwasmの勉強が目的なのでおあつらえ向きと言えます。

ただ、wasmにコンパイルする場合には1つ問題があります。Brainfuckは入出力を扱う必要があり、コマンドラインならば標準入出力がそれに当たります。しかしwasm自体の主な機能は数値演算で、標準入出力を含むOSの機能を使うための仕組みがないのです。

そこで必要となるのがWASI（WebAssembly System Interface）です。WASI（WebAssembly System Interface）は名前の通りwasmプログラムからOSの機能を使うためのインターフェースです。WASIで定められたシグネチャを持つ実装をwasmの実行時に渡してあげることで標準入出力も扱えるようになります<!-- TODO: ソフトウェアデザインの紹介-->。上で紹介したWasmtimeやWasmerはWASIランタイムです。

ブラウザ外でのwasm利用は今後広まっていくことが予想されるので、いまコンパイラを書いておけば波に乗り遅れずに済みそうです。

## 本稿の構成
そんなこんなでコンパイラを書きましたので、本稿の目的を「WASIを使うwasmコードの作りかた」に据えていきます。以下のような流れで進行します。
- コンパイラの大まかな構成
- 実装に必要な範囲でのwasmとWASIの説明
- Brainfuckの各命令とそれに対応するwasmコードの説明
- 実行例

そして、以下の内容は**扱いません**。
- ブラウザでの実行方法
- Rustで書いたコンパイラのソースコードの解説
- Brainfuckの最適化

ブラウザの話は冒頭でも書いた通りで、今回はコマンドラインで使えるwasm（WASI）ランタイムでの実行を前提としています。また、命令の少なさに甘えて素朴に文字列として書き出すだけの雑実装にしたので、ソースコード自体には大した工夫はありません。最後のBrainfuckの最適化についてですが、今回の実装は筆者が以前[こちらの記事](https://postd.cc/adventures-in-jit-compilation-part-1-an-interpreter/)を参考にして書いたJITコンパイラからコードを流用しています。つまり、最適化についての詳細はそこに書いてあるのでそっちを参照してねということです。例外として、「連続した同じ命令を1つにまとめる」最適化は一言で説明すれば済むので扱います。

それでは本論に入っていきましょう。

# コンパイラの構成
このコンパイラは、Brainfuckプログラムのファイルを入力としてWebAssemblyのバイナリコードをファイル出力するプログラムです。WebAssemblyにはバイナリ形式とそれに対応するテキスト形式（以下wat）があります。ブラウザで実行するAPIが提供されているのは前者ですが、バイナリなので人間が読み書きするにはかなりつらいです。一方、後者は機械語に対するアセンブリのような位置づけのフォーマットで、見た目はほとんどS式なので普通に手書きできる程度には人間に優しいものです。今回は自前で実装するのはwatに生成するところまでにして、バイナリ形式への変換は別のライブラリに任せましょう。公式ツールである[wabt](https://github.com/WebAssembly/wabt)のRustバインディングを使います。

したがって、以下で説明するwasmコードは全てwatです。

# watとWASIの基礎
まずwatの基本事項について確認していきます。必要最低限の説明しかしないので、より詳しく知りたい場合は[MDNの記事](https://developer.mozilla.org/ja/docs/WebAssembly/Understanding_the_text_format)や[仕様](https://webassembly.github.io/spec/core/index.html)を参照して下さい。

さて、wasmプログラムはモジュールから構成されています。

```
(module) ;; これはコメント
```
わざわざ宣言文が用意されているので複数宣言できそうな気がしてしまいますが、現在の仕様では1プログラムにつき1モジュールのようです。これは何も定義していない空のモジュールですが正しいwatです。

モジュール内には様々なコンポーネントを配置できますが、今回必要なのは`func`, `global`, `memory`, `export`, `import`の5つです。実際の処理内容は`func`の中身に記述していくため一番重要なのは`func`です。まずは`func`の宣言方法と処理の記述方法について見てみましょう。

## func
### 宣言
`$f`という名前で関数を宣言してみましょう。

```
(module
    (func $f)
)
```

名前はオプショナルなので単に`(func)`とも書けます。名前を付けなくても、宣言順に0始まりの添え字が割り当てられるのでそれを使って参照できます（呼び出しについては後述）。

引数を受け取りたい場合は宣言を次のように変更します。

```
(func $f (param i32) (param i32))
```

これでi32型の値を2つ引数として受け取る関数を定義できました。

### 呼び出し
これを他の関数から呼び出すときは次のように書きます。

```
(func $f (param i32) (param i32))
(func $g
    i32.const 1
    i32.const 2
    call $f ;; `call 0`でもよい
)
```

wasmはスタックマシンなので、スタックにオペランドをプッシュしておき、それをポップして演算を呼び出していきます。上の例ではi32の`1`と`2`を引数として`$f`を呼び出しています。自分はこう書いた方がスタックマシンっぽくて好んで書いていますが、S式っぽく次のようにも書けます。

```
(call $f (i32.const 1) (i32.const 2))
```

「ではどうやって`$f`の中で引数を使うのか？」という疑問が浮かぶと思いますが、実は今回必要となるのは引数を取る関数の宣言方法だけなのでなんと説明しません。知りたい場合は冒頭で挙げた参考文献をあたって下さい。

### 数値演算
これは`1 + 2`を実行する関数です。

```
(func
    ;; (i32.add (i32.const 1) (i32.const 2))でもよい
    i32.const 1
    i32.const 2
    i32.add
    drop
)
```

`i32.add`はスタックから2つ値をポップして、それらを足し合わせた結果をスタックに積む演算です。最後の`drop`はスタックの最上位を破棄する命令です。スタックに値があると関数の戻り値として解釈されますが、この関数は戻り値がないことになっているためエラーになります。戻り値を設定することもできますが、やはり今回は必要ないのでスルーします。

もちろん`i32.add`以外にも基本的なi32演算は揃っていますが、他の演算については必要になったときに紹介していくことにして`global`コンポーネントの説明に移ります。

## global
グローバル変数を定義するの用います。

```
(global $g (mut i32) (i32.const 1))
(func
    global.get $g ;; `global.get 0`も可
    i32.const 2
    i32.add
    drop
)
```

これも`1 + 2`を実行して捨てるコードです。ここでは関数で説明したのと同じやり方で、グローバル変数に名前`$g`を割り当てています。名前を付けなくても添え字でアクセスできるのも同様です。`mut i32`は変更可能なi32型の値であることを表し、`i32.const 1`は初期値が`1`であることを示しています。

次のコードはこのグローバル変数を`2`に変更するものです。

```
(func
    i32.const 2
    global.set $g
)
```

## memory
メモリを初期化するためのセクションです。メモリは1バイトずつ格納する単なる一次元配列で、1ページ64KiBとして宣言時に最小のページ数を指定します。

```
(module
    (memory 1)
)
```

こうすると1ページのメモリを確保できます。中身は全て`0`で初期化されています。メモリへの値の保存は関数の中で行います。これは「メモリのオフセット0の位置に`1`を格納する」処理になります。

```
(func
    ;; (i32.store8 (i32.const 0) (i32.const 1))でも可
    i32.const 0
    i32.const 1
    i32.store8
)
```

ストア命令には注意が必要です。i32型のストア命令には`i32.store8`, `i32.store16`, `i32.store`の3種類があり、使う命令を間違えると意図しない書き込みが行われてしまいます。これらは第一引数のi32値をオフセットとして、それぞれ8ビット、16ビット、32ビットを書き込む命令です。例えば今のメモリの状態がこんな風になっているとします。

|番地|値（1バイト）|
|:-:|:-:|
|0|0|
|1|10|
|2|20|
|3|30|

この状態で次のような命令を実行するとどうなるでしょうか。

```
i32.const 0
i32.const 1
i32.store
```

第一引数はあくまでオフセットなので、`0`から初めて32ビットを書き込むことになります。`1`を32ビットの二進数で書くと`00000000000000000000000000000001`なので、実行後の状態はこうなります。

|番地|値|
|:-:|:-:|
|0|1|
|1|0|
|2|0|
|3|0|

1, 2, 3番目のセルが0で上書きされています。n番目のセルだけに8ビット範囲の整数を書き込みたい場合は`i32.store8`を使います。

メモリからの読み込みについても同様の注意が必要です。`i32.load`命令は第一引数のオフセット値から32ビットを読み込むので、

|番地|値|
|:-:|:-:|
|0|0|
|1|10|
|2|20|
|3|30|

の状態で`(i32.load (i32.const 0))`を実行するとスタックの一番上には`504629760`が積まれます。`(30 << 24) + (20 << 16) + (10 << 8) + 0`と等しいですね。よって、ちょうど0番目のセルのバイトだけを読んでスタックに積みたい場合はこう書きます。

```
i32.const 0
i32.load8_u
```

`_u`というサフィックスは符号なし整数として読み込むという意味です。符号ありとして読み込む場合は`i32.load8_s`を使いますがやはり今回は使いません。

<!-- この節ではBrainfuckコンパイラ実装に必要なwatとWASIの仕様について解説していきます。話が前後することにはなりますが、Brainfuckの命令を実行するために必要な機能を天下り的に示しておきます。Brainfuckの仕様は次の節で提示します。

- データポインタの保持
- メモリへの値のストア
- メモリからの値のロード
- 足し算と引き算
- 標準入出力
- 条件分岐とループ

「標準入出力」以外はwasm単体の機能で実現できます。 -->

# コード生成
## Brainfuckの仕様
Brainfuckの仕様を[Wikipedia](https://ja.wikipedia.org/wiki/Brainfuck#Brainfuck%E3%81%AE%E8%A8%80%E8%AA%9E%E4%BB%95%E6%A7%98)から引用します。すでにご存知の方は次の小節まで読み飛ばしても大丈夫です。

> 処理系は次の要素から成る: Brainfuckプログラム、インストラクションポインタ（プログラム中のある文字を指す）、少なくとも30000個の要素を持つバイトの配列（各要素はゼロで初期化される）、データポインタ（前述の配列のどれかの要素を指す。最も左の要素を指すよう初期化される）、入力と出力の2つのバイトストリーム。
> Brainfuckプログラムは、以下の8個の実行可能な命令から成る（他の文字は無視され、読み飛ばされる）。
>
> `>` ポインタをインクリメントする。ポインタをptrとすると、C言語の「ptr++;」に相当する。
> `<` ポインタをデクリメントする。C言語の「ptr--;」に相当。
> `+` ポインタが指す値をインクリメントする。C言語の「(*ptr)++;」に相当。
> `-` ポインタが指す値をデクリメントする。C言語の「(*ptr)--;」に相当。
> `.` ポインタが指す値を出力に書き出す。C言語の「putchar(*ptr);」に相当。
> `,` 入力から1バイト読み込んで、ポインタが指す先に代入する。C言語の「*ptr=getchar();」に相当。
> `[` ポインタが指す値が0なら、対応する ] の直後にジャンプする。C言語の「while(*ptr){」に相当。
> `]` ポインタが指す値が0でないなら、対応する [ （の直後）にジャンプする。C言語の「}」に相当。

例として`12345`という文字列を出力するBrainfuckプログラムを載せておきます。`//`以下はコメントの気持ちで書いてます。Brainfuckにはコメント機能などありませんが、仕様にあるように無関係な文字は全て無視されるので、以下のプログラムは文法的に正しいBrainfuckプログラムです。

```
++++++++ ++++++++ ++++++++ ++++++++ ++++++++ ++++++++ // ポインタ0の値を48にする。ASCIIでは0
>+++++ // ポインタ1の値を5に。ループ用
[<+.>-] // ポインタ1が0になるまでポインタ0の値に1を加算して出力
```
